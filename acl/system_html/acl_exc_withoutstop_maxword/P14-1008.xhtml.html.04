<html>
<head>
<title>P14-1008.xhtml_1.pickle</title>
</head>
<body bgcolor="white">
<a name="0">[0]</a> <a href="#0" id=0>This formulation keeps the simpleness and computability of DCS trees mostly unaffected; for example, our semantic calculation for DCS trees is parallel to the denotation computation in original DCS</a>
<a name="1">[1]</a> <a href="#1" id=1>The abstract denotation of a germ is defined in a top-down manner for the root node u'\u03a1' of a DCS tree u'\ud835' u'\udcaf' , we define its denotation [[ u'\u03a1' ]] u'\ud835' u'\udcaf' as the denotation of the entire tree [[ u'\ud835' u'\udcaf' ]] ; for a non-root node u'\u03a4' and its parent node u'\u03a3' , let the edge ( u'\u03a3' , u'\u03a4' ) be labeled by semantic roles ( r , r u'\u2032' ) , then define</a>
<a name="2">[2]</a> <a href="#2" id=2>Furthermore, since the on-the-fly knowledge is generated by transformed pairs of DCS trees, all contexts are preserved in Figure 6 , though the tree transformation can be seen as generated from the entailment rule u'\u201c' X is blamed for death u'\u2192' X causes loss of life u'\u201d' , the generated on-the-fly knowledge, as shown above the trees, only fires with the additional condition that X is a tropical storm and is Debby</a>
<a name="3">[3]</a> <a href="#3" id=3>Our solution is to redefine DCS trees without the aid of any databases, by considering each node of a DCS tree as a content word in a sentence (but may no longer be a table in a specific database), while each edge represents semantic relations between two words</a>
<a name="4">[4]</a> <a href="#4" id=4>To obtain DCS trees from natural language, we use Stanford CoreNLP 5 5 http://nlp.stanford.edu/software/corenlp.shtml for dependency parsing [] , and convert Stanford dependencies to DCS trees by pattern matching on POS tags and dependency labels</a>
<a name="5">[5]</a> <a href="#5" id=5>The idea is to borrow a minimal set of operators from relational algebra [] , which is already able to formulate the calculation in DCS and define abstract denotation , which is an abstraction of the computation of denotations guided by DCS trees</a>
<a name="6">[6]</a> <a href="#6" id=6>Most of the problems do not require lexical knowledge, so we use our primary textual inference system without on-the-fly knowledge nor WordNet, to test the performance of the DCS framework as formal semantics</a>
<a name="7">[7]</a> <a href="#7" id=7>To formulate the database querying process defined by a DCS tree, we provide formal semantics to DCS trees by employing relational algebra [] for representing the query</a>
<a name="8">[8]</a> <a href="#8" id=8>In this section we describe the idea of representing natural language semantics by DCS trees, and achieving inference by computing logical relations among the corresponding abstract denotations</a>
<a name="9">[9]</a> <a href="#9" id=9>Moreover, to compensate the lack of background knowledge in practical inference, we combine our framework with the idea of tree transformation [] , to propose a way of generating knowledge in logical representation from entailment rules [] , which are by now typically considered as syntactic rewriting rules</a>
<a name="10">[10]</a> <a href="#10" id=10>The strict semantics of DCS trees brings us the idea of applying DCS to logical inference</a>
<a name="11">[11]</a> <a href="#11" id=11>Technically, each germ in a DCS tree indicates a variable when the DCS tree is translated to a FOL formula, and the abstract denotation of the germ corresponds to the set of consistent values [] of that variable</a>
<a name="12">[12]</a> <a href="#12" id=12>Since meanings of sentences are represented by statements on abstract denotations, logical inference among sentences is reduced to deriving new relations among abstract denotations</a>
<a name="13">[13]</a> <a href="#13" id=13>A DCS tree u'\ud835' u'\udcaf' = ( u'\ud835' u'\udca9' , u'\u2130' ) is defined as a rooted tree, where each node u'\u03a3' u'\u2208' u'\ud835' u'\udca9' is labeled with a content word w u'\u2062' ( u'\u03a3' ) and each edge ( u'\u03a3' , u'\u03a3' u'\u2032' ) u'\u2208' u'\u2130' u'\u2282' u'\ud835' u'\udca9' u'\ud835' u'\udca9' is labeled with a pair of semantic roles ( r , r u'\u2032' ) 7 7 The definition differs slightly from the original , mainly for the sake of simplicity and clarity</a>
<a name="14">[14]</a> <a href="#14" id=14>For example, the similarity score of the path alignment u'\u201c' OBJ ( blame ) IOBJ - ARG ( death ) u'\u2248' SUBJ ( cause ) OBJ - ARG ( loss ) MOD - ARG ( life ) u'\u201d' is calculated as the cosine similarity of vectors blame + death and cause + loss + life</a>
<a name="15">[15]</a> <a href="#15" id=15>The experiments show i) a competitive</a>
</body>
</html>