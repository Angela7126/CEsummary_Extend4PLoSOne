<html>
<head>
<title>P14-1008.xhtml_1.pickle</title>
</head>
<body bgcolor="white">
<a name="0">[0]</a> <a href="#0" id=0>As the semantics of DCS trees is formulated by abstract denotations, the meanings of declarative sentences are represented by statements on abstract denotations</a>
<a name="1">[1]</a> <a href="#1" id=1>In this section we describe the idea of representing natural language semantics by DCS trees, and achieving inference by computing logical relations among the corresponding abstract denotations</a>
<a name="2">[2]</a> <a href="#2" id=2>To formulate the database querying process defined by a DCS tree, we provide formal semantics to DCS trees by employing relational algebra [] for representing the query</a>
<a name="3">[3]</a> <a href="#3" id=3>The strict semantics of DCS trees brings us the idea of applying DCS to logical inference</a>
<a name="4">[4]</a> <a href="#4" id=4>Since meanings of sentences are represented by statements on abstract denotations, logical inference among sentences is reduced to deriving new relations among abstract denotations</a>
<a name="5">[5]</a> <a href="#5" id=5>This formulation keeps the simpleness and computability of DCS trees mostly unaffected; for example, our semantic calculation for DCS trees is parallel to the denotation computation in original DCS</a>
<a name="6">[6]</a> <a href="#6" id=6>As described below, we represent meanings of sentences with abstract denotations , and logical relations among sentences are computed as relations among their abstract denotations</a>
<a name="7">[7]</a> <a href="#7" id=7>We obtain DCS trees from dependency trees, to bypass the need of a concrete database</a>
<a name="8">[8]</a> <a href="#8" id=8>The idea is to borrow a minimal set of operators from relational algebra [] , which is already able to formulate the calculation in DCS and define abstract denotation , which is an abstraction of the computation of denotations guided by DCS trees</a>
<a name="9">[9]</a> <a href="#9" id=9>On-the-fly knowledge is generated by aligning paths in DCS trees</a>
<a name="10">[10]</a> <a href="#10" id=10>DCS trees has been proposed to represent natural language semantics with a structure similar to dependency trees [] (Figure 1</a>
<a name="11">[11]</a> <a href="#11" id=11>As a comparison, studied the proportion of proven pairs and precision by applying DIRT rules to tree skeletons in RTE2 and RTE3 data</a>
<a name="12">[12]</a> <a href="#12" id=12>Perform rule-based conversion from dependency parses to DCS trees, which are translated to statements on abstract denotations</a>
<a name="13">[13]</a> <a href="#13" id=13>Meanings of sentences then can be represented by primary relations among abstract denotations</a>
<a name="14">[14]</a> <a href="#14" id=14>Our solution is to redefine DCS trees without the aid of any databases, by considering each node of a DCS tree as a content word in a sentence (but may no longer be a table in a specific database), while each edge represents semantic relations between two words</a>
<a name="15">[15]</a> <a href="#15" id=15>6 6 In [] DCS trees are learned from QA pairs and database entries</a>
<a name="16">[16]</a> <a href="#16" id=16>Based on abstract denotations, we briefly describe our process to apply DCS to textual inference</a>
<a name="17">[17]</a> <a href="#17" id=17>We built an inference engine to perform logical inference on abstract denotations as above</a>
<a name="18">[18]</a> <a href="#18" id=18>To obtain DCS trees from natural language, we use Stanford CoreNLP 5 5 http://nlp.stanford.edu/software/corenlp.shtml for dependency parsing [] , and convert Stanford dependencies to DCS trees by pattern matching on POS tags and dependency labels</a>
<a name="19">[19]</a> <a href="#19" id=19>Summing up test data from RTE2 to RTE5, Figure 7 shows the proportion of all proven pairs and their precision</a>
<a name="20">[20]</a> <a href="#20" id=20>Most of the problems do not require lexical knowledge, so we use our primary textual inference system without on-the-fly knowledge nor WordNet, to test the performance of the DCS framework as formal semantics</a>
<a name="21">[21]</a> <a href="#21" id=21>Applied by our logical system, the noisy on-the-fly knowledge can achieve a precision comparable to higher quality resources such as DIRT</a>
<a name="22">[22]</a> <a href="#22" id=22>For example, Figure 5 shows DCS trees of the following sentences (a simplified pair from RTE2-dev</a>
<a name="23">[23]</a> <a href="#23" id=23>Convert accepted path alignments into statements on abstract denotations, use them in logical inference as new knowledge, and try to prove H again</a>
<a name="24">[24]</a> <a href="#24" id=24>An inference engine is built to handle inference on abstract denotations</a>
<a name="25">[25]</a> <a href="#25" id=25>Abstract denotations and statements are convenient for representing semantics of various types of expressions and linguistic knowledge</a>
<a name="26">[26]</a> <a href="#26" id=26>If H is not proven, compare DCS trees of T and H , and generate path alignments</a>
<a name="27">[27]</a> <a href="#27" id=27>Statements are declarations of some relations among abstract denotations, for which we consider the following set relations</a>
<a name="28">[28]</a> <a href="#28" id=28>Abstract denotation of a DCS tree can be calculated in a bottom-up manner</a>
<a name="29">[29]</a> <a href="#29" id=29>A path is considered as joining two germs in a DCS tree, where a germ is defined as a specific semantic role of a node</a>
<a name="30">[30]</a> <a href="#30" id=30>In this logical system, we treat abstract denotations as terms and statements as</a>
</body>
</html>