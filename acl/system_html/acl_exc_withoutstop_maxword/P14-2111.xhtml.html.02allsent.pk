(lp0
VThe principal contributions of our work are i) we show that a discriminative sequence labeling model is apt for text normalization and performs at state-of-the-art levels with small amounts of labeled training data; (ii) we show that character-level neural text embeddings can be used to effectively incorporate information from unlabeled data into the model and can substantially boost text normalization performance
p1
aVIn this work we suggest a simple, supervised character-level string transduction model which easily incorporates features automatically learned from large amounts of unlabeled data and needs only a limited amount of labeled training data and no lexical resources
p2
aVAs our evaluation metric we use word error rate (WER) which is defined as the Levenshtein edit distance between the predicted word sequence t ^ and the target word sequence t , normalized by the total number of words in the target string
p3
aVA stream of posts from Twitter contains text written in a large variety of languages and writing systems, in registers ranging from formal to internet slang
p4
aVA multitude of resources and approaches have been used to deal with normalization hand-crafted and (semi-)automatically induced dictionaries, language models, finite state transducers, machine translation models and combinations thereof
p5
aVIt also suffers from language model mismatch mentioned in Section 2 optimal results were obtained by using a low weight for the language model trained on a balanced text corpus
p6
aVA more generally applicable metric would be character error rate, but we report WERs to make our results easily comparable with previous work
p7
aVThe rest of each row shows the nearest neighbors of this string in embedding space, i.e., strings for which the SRN is activated in a similar way when predicting its last byte as measured by cosine similarity
p8
aVOur supervised approach makes it easy to address the first type of failure by simply annotating additional training examples
p9
aVFor English, Han and Baldwin ( 12 ) created a small tweet dataset annotated with normalized variants at the word level
p10
aVAs our sequence labeling model we use the Wapiti implementation of Conditional Random Fields ( 16 ) with the L-BFGS optimizer and elastic net regularization with default settings
p11
aVSimple Recurrent Networks (SRNs) were introduced by Elman ( 7 ) as models of temporal, or sequential, structure in data, including linguistic data ( 8
p12
aVOne of the main advantages of the noisy channel decomposition is that is makes it easy to exploit large amounts of unlabeled data in the form of a language model
p13
aVIn addition to character n-gram features they use phoneme and syllable features, while we rely on the SRN embeddings to provide generalized representations of input strings
p14
aV18 , 17 ) shows some similarities to ours they gather a collection of OOV words together with their canonical forms from the web and train a character-level CRF sequence labeler on the edit sequences computed from these pairs
p15
aVWe thus propose an alternative approach where normalization is modeled directly, and which enables easy incorporation of unlabeled data from the source domain
p16
aVThe training data for the model is generated by computing shortest edit scripts for pairs of original and normalized strings
p17
aVWe modified the RNNLM toolkit ( 20 ) to record the activations of the hidden layer and ran it with the default learning rate schedule
p18
aVThe representation of recent history is stored in a limited number of recurrently connected hidden units
p19
aVTo keep model size within manageable limits we reduced the label set for models all-words and document by replacing labels which occur less than twice in the training data with nil
p20
aVKaufmann and Kalita ( 14 ) trained a phrase-based statistical translation model on a parallel text message corpus and applied it to tweet normalization
p21
aVIn order to train our SRN language model we collected a set of tweets using the Twitter sampling API
p22
aVSubstantial effort has been expended in recent years to adapt standard NLP processing pipelines to be able to deal with such content
p23
aVThe trained SRN language model can be used to generate random text by sampling the next byte from its predictive distribution and extending the string with the result
p24
aVModel oov-only exploits the setting when the task is constrained to only normalize words absent from a reference dictionary, while document is the one most generally applicable but does not benefit from any constraints
p25
aVGiven that training SRNs on large amounts of text takes a considerable amount of time we did not vary the size of the hidden layer
p26
aVSince the English dataset is pre-tokenized and only covers word-to-word transformations, this choice has little importance here and character error rates show a similar pattern to word error rates
p27
aVUnlabeled data is incorporated following recent work on using character-level text embeddings for text segmentation ( 4 ) , and word and sentence boundary detection ( 9
p28
aVIn order to maximize the size of the training data while avoiding tuning on test data we use a split cross-validation setup we generate 10 cross-validation folds, and use 5 of them during development to evaluate variants of our model
p29
aVOnce trained the model is used to label new strings and the predicted edit script is applied to the input string producing the normalized output string
p30
aVTable 5 shows the non-unique normalizations which were missed by the best model they are a mixture of relatively standard variations which happen to be infrequent in our data, like tonite or gf , and a few idiosyncratic respellings like uu or bhee
p31
aVWe did try to filter tweets by language and create specific embeddings for English but this had negligible effect on tweet normalization performance
p32
aVOur model learns sequences of edit operations from labeled data using a Conditional Random Field ( 15
p33
aVOne approach has been text normalization, i.e., transforming tweet text into a more canonical form which standard NLP tools expect
p34
aVFor all model variations, adding SRN features substantially improves performance the relative error reductions range from 12% for oov-only to 30% for all-words
p35
aVThis approach sacrifices some generality, since transformations involving multiple words cannot be learned
p36
aVOur string transduction model works by learning the sequence of edits which transform the input string into the output string
p37
aVMany authors evaluate on private tweet collections and/or on the text message corpus of Choudhury et al
p38
aV9 ) use character-level SRN text embeddings for learning segmentation, and recurrent nets themselves have been used for sequence transduction ( 11 ) , to our knowledge neural text embeddings have not been previously applied to string transduction
p39
aVFigure 1 shows example strings generated in this way the network seems to prefer to output pseudo-tweets written consistently in a single script with words and pseudo-words mostly from a single language
p40
aVMany approaches to text normalization adopt the noisy channel setting, where the model normalizing source string s into target canonical form t is factored into two parts t ^ = arg u'\u005cu2062' max t P ( t ) P ( s t
p41
aVThese activation vectors form our text embeddings they are discretized and used as input features to the supervised sequence labeler as described in Section 3.4
p42
aVWe use SRNs to induce character-level text representations from unlabeled Twitter data to use as features in the string transduction model
p43
aVWe use a sequence labeling model to learn to label input strings with edit scripts
p44
aVWe limit the size of the string alphabet by always working with UTF-8 encoded strings, and using bytes rather than characters as basic units
p45
aVThe error term P ( s t ) models how canonical strings are transformed into variants such as e.g., misspellings, emphatic lengthenings or abbreviations
p46
aVFor the n-gram+srn feature set we augment n-gram with features derived from the activations of the hidden units as the SRN is trying to predict the current character
p47
aVWhen run on new strings, the activations of the units in the hidden layer at each position in the string are recorded and used as features for training the string transduction model
p48
aVWe use them to bring in information from unlabeled data into our string transduction model and then train a character-level SRN language model on unlabeled tweets
p49
aVThis forces the network to make the representation compressed and abstract rather than just memorize literal history
p50
aVA difficulty in comparing approaches to tweet normalization is the sparsity of publicly available datasets
p51
aVMany other tweet normalization methods work in a word-wise fashion they first identify OOV words and then replace them with normalized forms
p52
aVMore recently SRNs were used as language models for speech recognition and shown to outperform classical n-gram language models ( 19 ; 21
p53
aVWe run the trained model on new tweets and record the activation of the hidden layer at each position as the model predicts the next character
p54
aVoov-only is trained on individual words and in-vocabulary (IV) words are discarded for training, and left unchanged for prediction
p55
aVThe sample consists of 414 million bytes of UTF-8 encoded in a variety of languages and scripts text
p56
aVIt is hard to interpret the results from Han and Baldwin ( 12 ) , as the evaluation is carried out by assuming that the words to be normalized are known in advance
p57
aVThey still require annotated development data for tuning parameters and a variety of heuristics
p58
aVThe simplest way to normalize tweets with a string transduction model is to treat whole tweets as input sequences
p59
aV6 ) propose a discriminative model for string transductions and apply it to morphological tasks
p60
aVWe train a recurrent neural network language model ( 19 ; 21 ) on a large collection of tweets
p61
aVTable 6 presents evaluation results of several approaches reported in Han et al
p62
aV1 1 The input string is extended with an empty symbol to account for the cases where an insertion is needed at the end of the string
p63
aVThe input vector w u'\u005cu2062' ( t ) represents the input element at current time step, here the current character
p64
aVThe activation s j of a hidden unit j is a function of the current input and the state of the hidden layer at the previous time step t - 1
p65
aVThis is because it is not obvious what kind of data can be used to estimate the language model there is plentiful text from the source domain, but little of it is in normalized target form
p66
aVWe use the raw sample directly without filtering it in any way, relying on the SRN to learn the structure of the data
p67
aV3 ) use edit scripts to learn lemmatization rules while Dreyer et al
p68
aVGiven a pair of strings such a sequence of edits (known as the shortest edit script) can be found using the Diff algorithm ( 22 ; 23
p69
aVThe hidden layer predicts the state of the output units at the next time step t + 1
p70
aVAnother version of recurrent neural nets has been used to generate plausible text with a character-level language model ( 24
p71
aVFurther afield, our work has connections to research on morphological analysis for example Chrupa u'\u005cu0141' a et al
p72
aVTable 1 shows a shortest edit script for the pair of strings ( c wat, see what
p73
aVThe units in the hidden layer at time t receive connections from input units at time t and also from the hidden units at the previous time step t - 1
p74
aVAs expected the most constrained model oov-only outperforms the more generic models on this dataset
p75
aVIn the field of tweet normalization the approach of Liu et al
p76
aVOur approach works well with similar-sized training data, and unlike unsupervised approaches can easily benefit from more if it becomes available
p77
aVIn comparison to our first-order linear-chain CRF, an MT model with reordering is more flexible but for this reason needs more training data
p78
aVIn Table 2 in the first column we show the suffix of a string for which the SRN is predicting the last byte
p79
aVAnother limitation is that only word-level normalization is covered in the annotation; e.g., splitting or merging of words is not allowed
p80
aVConsequently, publicly available normalization datasets are annotated at word level
p81
aVTable 4 shows the non-unique normalizations made by the oov-only model with SRN features which were missed without them
p82
aVThe generated byte sequences are valid UTF-8 strings
p83
aVWe can emulate this setup by training the sequence labeler on words, instead of whole tweets
p84
aVTable 3 shows the results of our development experiments
p85
aV9 ) show that these text embeddings can be useful as features in textual segmentation tasks
p86
aVWe trained a 400-hidden-unit SRN, to predict the next byte in the sequence using backpropagation through time
p87
aV13 ) dataset, which are automatically derived from the aspell dictionary
p88
aVWe think this decomposition is less appropriate in the context of text normalization than in applications from which it was borrowed such as Machine Translations
p89
aV10 ) ; S-dict is the automatically constructed dictionary from ( 13 ) ; Dict-combo are all the dictionaries combined and Dict-combo+HB-norm are all dictionaries combined with approach of Han and Baldwin ( 12
p90
aV13 ) remedy this shortcoming by evaluating a number of systems without pre-specifying ill-formed tokens
p91
aVall-words is trained on all words and allowed to change IV words
p92
aVThe language model P u'\u005cu2062' ( t ) encodes which target strings are probable
p93
aV13 ) are unsupervised but they typically use many adjustable parameters which need to be tuned on some annotated data
p94
aVThe output vector y u'\u005cu2062' ( t ) represents the predicted probabilities for the next character
p95
aVThey use this as the error model in a noisy-channel setup combined with a unigram language model
p96
aVAs a sequence labeler we use Conditional Random Fields ( 15
p97
aVGHM-dict is the automatically constructed dictionary from Gouws et al
p98
aVWe run experiments with two feature sets n-gram and n-gram+srn n-gram are character n-grams of size 1 u'\u005cu2013' 3 in a window of ( - 2 , + 2 ) around the current position
p99
aVHB-dict is the Internet slang dictionary from Han and Baldwin ( 12
p100
aVThe best performing configuration is then evaluated on the remaining 5 cross-validation folds
p101
aVdel u'\u005cu2013' delete character at this position
p102
aVNo-op is a baseline which leaves text unchanged
p103
aVMethods such as those of Han and Baldwin ( 12 ) , Liu et al
p104
aVGiven source string s the predicted target string t ^ is
p105
aVwhere u'\u005cu03a3' is the sigmoid function and U j u'\u005cu2062' i is the weight between input component i and hidden unit j , while W j u'\u005cu2062' l is the weight between hidden unit l at time t - 1 and hidden unit j at time t
p106
aVIn order to use the activations in the CRF model we discretize them as follows
p107
aVInput bytes were encoded using one-hot representation
p108
aVOnly the combination of all the dictionaries comes close in performance
p109
aVThis advantage does not hold for text normalization
p110
aVOur version of Diff uses the following types of edits
p111
aVThe score on the full dataset is a bit better: 4.66%
p112
aVSRN features seem to be especially useful for learning long-range, multi-character edits, e.g., fb for facebook
p113
aVins ( u'\u005cu22c5' ) u'\u005cu2013' insert specified string before character at this position
p114
aVThe WER reported for oov-only ngram+srn is on the test folds only
p115
aVwhere e = ses u'\u005cu2062' ( s , t ) is the shortest edit script mapping s to t
p116
aVHowever, word-wise models are more comparable with previous work
p117
aVP ( e s ) is modeled with a linear-chain Conditional Random Field
p118
aVDocument is trained on whole tweets
p119
aVMany other approaches to tweet normalization are more unsupervised in nature (e.g., 12 ; 10 ; 25 ; 13
p120
aVChrupa u'\u005cu0141' a ( 4 ) and Evang et al
p121
aVHan et al
p122
aV549 tweets, which contain 2139 annotated out-of-vocabulary (OOV) words
p123
aVThere is also much edited text such as news text, but it comes from a very different domain
p124
aVFor oov-only we were able to use the full label set
p125
aVWhile Chrupa u'\u005cu0141' a ( 4 ) and Evang et al
p126
aVWe investigated the following models
p127
aVAs can be seen our approach it the best performing approach overall and in particular it does much better than all of the single dictionary-based methods
p128
aVnil u'\u005cu2013' no edits
p129
aV18 ) , Gouws et al
p130
aVThe dataset is also rather small
p131
aVNevertheless, we use it here for training and evaluating our model
p132
aV2 2 We used the IV/OOV annotations in the Han et al
p133
aVFor each of the K = 10 most active units out of total J = 400 hidden units, we create features ( f u'\u005cu2062' ( 1 ) u'\u005cu2062' u'\u005cu2026' u'\u005cu2062' f u'\u005cu2062' ( K ) ) defined as f u'\u005cu2062' ( k ) = 1 if s j u'\u005cu2062' ( k ) 0.5 and f u'\u005cu2062' ( k ) = 0 otherwise, where s j u'\u005cu2062' ( k ) returns the activation of the k th most active unit
p134
aV13 ) as well as the model which did best in our development experiments
p135
aV10 ) or Han et al
p136
aVThis dataset does not specify a development/test split
p137
aV2 )
p138
a.