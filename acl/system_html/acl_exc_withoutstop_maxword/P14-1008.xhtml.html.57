<html>
<head>
<title>P14-1008.xhtml_1.pickle</title>
</head>
<body bgcolor="white">
<a name="0">[0]</a> <a href="#0" id=0>On-the-fly knowledge is generated by aligning paths in DCS trees</a>
<a name="1">[1]</a> <a href="#1" id=1>Based on abstract denotations, we briefly describe our process to apply DCS to textual inference</a>
<a name="2">[2]</a> <a href="#2" id=2>Since meanings of sentences are represented by statements on abstract denotations, logical inference among sentences is reduced to deriving new relations among abstract denotations</a>
<a name="3">[3]</a> <a href="#3" id=3>To formulate the database querying process defined by a DCS tree, we provide formal semantics to DCS trees by employing relational algebra [] for representing the query</a>
<a name="4">[4]</a> <a href="#4" id=4>We built an inference engine to perform logical inference on abstract denotations as above</a>
<a name="5">[5]</a> <a href="#5" id=5>The conversion is done by first performing a DCS tree transformation according to the aligned paths, and then declare a subsumption relation between the denotations of aligned germs</a>
<a name="6">[6]</a> <a href="#6" id=6>Abstract denotations and statements are convenient for representing semantics of various types of expressions and linguistic knowledge</a>
<a name="7">[7]</a> <a href="#7" id=7>Most of the problems do not require lexical knowledge, so we use our primary textual inference system without on-the-fly knowledge nor WordNet, to test the performance of the DCS framework as formal semantics</a>
<a name="8">[8]</a> <a href="#8" id=8>Furthermore, since the on-the-fly knowledge is generated by transformed pairs of DCS trees, all contexts are preserved in Figure 6 , though the tree transformation can be seen as generated from the entailment rule u'\u201c' X is blamed for death u'\u2192' X causes loss of life u'\u201d' , the generated on-the-fly knowledge, as shown above the trees, only fires with the additional condition that X is a tropical storm and is Debby</a>
<a name="9">[9]</a> <a href="#9" id=9>As described below, we represent meanings of sentences with abstract denotations , and logical relations among sentences are computed as relations among their abstract denotations</a>
<a name="10">[10]</a> <a href="#10" id=10>Accepted aligned paths are converted into statements, which are used as new knowledge</a>
<a name="11">[11]</a> <a href="#11" id=11>A path is considered as joining two germs in a DCS tree, where a germ is defined as a specific semantic role of a node</a>
<a name="12">[12]</a> <a href="#12" id=12>Technically, each germ in a DCS tree indicates a variable when the DCS tree is translated to a FOL formula, and the abstract denotation of the germ corresponds to the set of consistent values [] of that variable</a>
<a name="13">[13]</a> <a href="#13" id=13>For example, Figure 5 shows DCS trees of the following sentences (a simplified pair from RTE2-dev</a>
<a name="14">[14]</a> <a href="#14" id=14>Our solution is to redefine DCS trees without the aid of any databases, by considering each node of a DCS tree as a content word in a sentence (but may no longer be a table in a specific database), while each edge represents semantic relations between two words</a>
<a name="15">[15]</a> <a href="#15" id=15>The logical clue to align germs is if there exists an abstract denotation, other than W , that is a superset of both abstract denotations of two germs, then the two germs can be aligned</a>
<a name="16">[16]</a> <a href="#16" id=16>Two paths are aligned if the joined germs are aligned, and we impose constraints on aligned germs to inhibit meaningless alignments, as described below</a>
<a name="17">[17]</a> <a href="#17" id=17>Moreover, to compensate the lack of background knowledge in practical inference, we combine our framework with the idea of tree transformation [] , to propose a way of generating knowledge in logical representation from entailment rules [] , which are by now typically considered as syntactic rewriting rules</a>
<a name="18">[18]</a> <a href="#18" id=18>However, this method does not work for real-world datasets such as PASCAL RTE [] , because of the knowledge bottleneck it is often the case that the lack of sufficient linguistic knowledge causes failure of inference, thus the system outputs u'\u201c' no entailment u'\u201d' for almost all pairs []</a>
<a name="19">[19]</a> <a href="#19" id=19>In this logical system, we treat abstract denotations as terms and statements as atomic sentences , which are far more easier to handle than first order predicate logic (FOL) formulas</a>
<a name="20">[20]</a> <a href="#20" id=20>On PASCAL RTE datasets, strict logical inference is known to have very low recall [] , so on-the-fly knowledge is crucial in this setting</a>
<a name="21">[21]</a> <a href="#21" id=21>The threshold for accepted path alignments is set to 0.4 , based on pre-experiments on RTE development sets</a>
<a name="22">[22]</a> <a href="#22" id=22>The transparent syntax-to-semantics interface of DCS enables us to back off to NLP techniques during inference for catching up the lack of knowledge</a>
<a name="23">[23]</a> <a href="#23" id=23>For example, the similarity score of the path</a>
</body>
</html>