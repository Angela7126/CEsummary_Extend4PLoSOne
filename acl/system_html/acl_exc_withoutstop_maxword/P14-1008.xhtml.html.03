<html>
<head>
<title>P14-1008.xhtml_1.pickle</title>
</head>
<body bgcolor="white">
<a name="0">[0]</a> <a href="#0" id=0>Convert accepted path alignments into statements on abstract denotations, use them in logical inference as new knowledge, and try to prove H again</a>
<a name="1">[1]</a> <a href="#1" id=1>In this section we describe the idea of representing natural language semantics by DCS trees, and achieving inference by computing logical relations among the corresponding abstract denotations</a>
<a name="2">[2]</a> <a href="#2" id=2>If a node u'\u03a3' in a DCS tree u'\ud835' u'\udcaf' belongs to a mention cluster m , we take the abstract denotation [[ u'\ud835' u'\udcaf' u'\u03a3' ]] and make a selection s m u'\u2062' ([[ u'\ud835' u'\udcaf' u'\u03a3' ]]) , which is regarded as the abstract denotation of that mention</a>
<a name="3">[3]</a> <a href="#3" id=3>For example, the abstract denotation of germ u'\ud835' u'\ude70' u'\ud835' u'\ude81' u'\ud835' u'\ude76' u'\u2062' ( u'\ud835' u'\udc1b' u'\ud835' u'\udc28' u'\ud835' u'\udc28' u'\ud835' u'\udc24' ) in Figure 1 is defined as u'\u03a0' u'\ud835' u'\ude70' u'\ud835' u'\ude81' u'\ud835' u'\ude76' u'\u2062' ( u'\ud835' u'\udc1b' u'\ud835' u'\udc28' u'\ud835' u'\udc28' u'\ud835' u'\udc24' u'\u2229' u'\u03a0' u'\ud835' u'\ude7e' u'\ud835' u'\ude71' u'\ud835' u'\ude79' u'\u2062' ( u'\ud835' u'\udc2b' u'\ud835' u'\udc1e' u'\ud835' u'\udc1a' u'\ud835' u'\udc1d' u'\u2229' ( u'\ud835' u'\udc2c' u'\ud835' u'\udc2d' u'\ud835' u'\udc2e' u'\ud835' u'\udc1d' u'\ud835' u'\udc1e' u'\ud835' u'\udc27' u'\ud835' u'\udc2d' u'\ud835' u'\ude82' u'\ud835' u'\ude84' u'\ud835' u'\ude71' u'\ud835' u'\ude79' u'\ud835' u'\udc1b' u'\ud835' u'\udc28' u'\ud835' u'\udc28' u'\ud835' u'\udc24' u'\ud835' u'\ude7e' u'\ud835' u'\ude71' u'\ud835' u'\ude79' ) ) ) , meaning u'\u201c' books read by students u'\u201d'</a>
<a name="4">[4]</a> <a href="#4" id=4>As the semantics of DCS trees is formulated by abstract denotations, the meanings of declarative sentences are represented by statements on abstract denotations</a>
<a name="5">[5]</a> <a href="#5" id=5>In this paper, we equip DCS with logical inference , which, in one point of view, is u'\u201c' the best way of testing an NLP system u'\u2019' s semantic capacity u'\u201d' []</a>
<a name="6">[6]</a> <a href="#6" id=6>The germ u'\ud835' u'\ude7e' u'\ud835' u'\ude71' u'\ud835' u'\ude79' u'\u2062' ( u'\ud835' u'\udc1b' u'\ud835' u'\udc25' u'\ud835' u'\udc1a' u'\ud835' u'\udc26' u'\ud835' u'\udc1e' ) and germ u'\ud835' u'\ude70' u'\ud835' u'\ude81' u'\ud835' u'\ude76' u'\u2062' ( u'\ud835' u'\udc1d' u'\ud835' u'\udc1e' u'\ud835' u'\udc1a' u'\ud835' u'\udc2d' u'\ud835' u'\udc21' ) in DCS tree of T are joined by the underscored path</a>
<a name="7">[7]</a> <a href="#7" id=7>Similarly, denotation of germ u'\ud835' u'\ude7e' u'\ud835' u'\ude71' u'\ud835' u'\ude79' u'\u2062' ( u'\ud835' u'\udc1b' u'\ud835' u'\udc25' u'\ud835' u'\udc1a' u'\ud835' u'\udc26' u'\ud835' u'\udc1e' ) in T of Figure 5 indicates the object of u'\u201c' blame u'\u201d' as in the sentence u'\u201c' Tropical storm Debby is blamed for death u'\u201d' , which is a tropical storm , is Debby , etc</a>
<a name="8">[8]</a> <a href="#8" id=8>Furthermore, since the on-the-fly knowledge is generated by transformed pairs of DCS trees, all contexts are preserved in Figure 6 , though the tree transformation can be seen as generated from the entailment rule u'\u201c' X is blamed for death u'\u2192' X causes loss of life u'\u201d' , the generated on-the-fly knowledge, as shown above the trees, only fires with the additional condition that X is a tropical storm and is Debby</a>
<a name="9">[9]</a> <a href="#9" id=9>Since meanings of sentences are represented by statements on abstract denotations, logical inference among sentences is reduced to deriving new relations among abstract denotations</a>
<a name="10">[10]</a> <a href="#10" id=10>The abstract denotation of a germ is defined in a top-down manner for the root node u'\u03a1' of a DCS tree u'\ud835' u'\udcaf' , we define its denotation [[ u'\u03a1' ]] u'\ud835' u'\udcaf' as the denotation of the entire tree [[ u'\ud835' u'\udcaf' ]] ; for a non-root node u'\u03a4' and its parent node u'\u03a3' , let the edge ( u'\u03a3' , u'\u03a4' ) be labeled by semantic roles ( r , r u'\u2032' ) , then define</a>
<a name="11">[11]</a> <a href="#11" id=11>Most of the problems do not require lexical knowledge, so we use our primary textual inference system without on-the-fly knowledge nor WordNet, to test the performance of the DCS framework as formal semantics</a>
<a name="12">[12]</a> <a href="#12" id=12>Based on abstract denotations, we briefly describe our process to apply DCS to textual inference</a>
<a name="13">[13]</a> <a href="#13" id=13>We built an inference engine to perform logical inference on abstract denotations as above</a>
<a name="14">[14]</a> <a href="#14" id=14>Perform rule-based conversion from dependency parses to DCS trees, which are translated to statements on abstract denotations</a>
<a name="15">[15]</a> <a href="#15" id=15>The strict semantics of DCS trees brings us the idea of applying DCS to logical inference</a>
<a name="16">[16]</a> <a href="#16" id=16>On-the-fly knowledge is generated by aligning paths in DCS trees</a>
<a name="17">[17]</a> <a href="#17" id=17>we can use</a>
</body>
</html>