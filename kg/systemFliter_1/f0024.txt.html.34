<html>
<head>
<title>f0024.txt</title>
</head>
<body bgcolor="white">
<a name="0">[0]</a> <a href="#0" id=0>In my opinion, GPS was unsuccessful as a general problem solver, because problems don't take this form in general and because most of the knowledge about the common sense needed for problem solving and achieving goals is not simply representable in the form of rules for transforming expressions.</a>
<a name="1">[1]</a> <a href="#1" id=1>The Friedberg approach was successful in learning only how to move a single bit from one memory cell to another, and its scheme of rewarding instructions involved in successful runs by reducing their probability of modification was shown by Herbert Simon (a now substantiated rumor froma 1987 personal communication) to be inferior to testing each program thoroughly and completely scrapping any program that wasn't perfect.</a>
<a name="2">[2]</a> <a href="#2" id=2>While Friedberg's problem was learning from experience, all schemes for representing knowledge by program suffer from similar difficulties when the object is to combine disparate knowledge or to make programs that modify knowledge.</a>
<a name="3">[3]</a> <a href="#3" id=3>A small conceptual modification to a behavior is usually not represented by a small modification to the program, especially if machine language programs are used and any one small modification to the text of a program is considered as likely as any other.</a>
<a name="4">[4]</a> <a href="#4" id=4>However, a Prolog program incorporating this fragment directly can sterilize a container only by killing each bacterium individually and would require that some other part of the program successively generate the names of the bacteria.</a>
<a name="5">[5]</a> <a href="#5" id=5>Prolog represents a local optimum in this continuum, because Horn clauses are medium expressive but can be interpreted directly by a logical problem solver.</a>
<a name="6">[6]</a> <a href="#6" id=6>Newell's current candidate for general problem representation is SOAR (Laird, Newell and Rosenbloom 1987), which, as I understand it, is concerned with transforming one state to another, where the states need not be represented by expressions.</a>
<a name="7">[7]</a> <a href="#7" id=7>It seemed to me in 1958 that small modifications in behavior are most often representable as small modifications in beliefs about the world, and this requires a system that represents beliefs explicitly.</a>
<a name="8">[8]</a> <a href="#8" id=8>In the first place, using general purpose theorem provers made the programs run too slowly, since the theorem provers of 1969 (Green 1969) had no way of controlling the search.</a>
<a name="9">[9]</a> <a href="#9" id=9>A careful construction of the axiom might succeed in including the exceptions of penguins and dead birds, but clearly we can think up as many additional exceptions like birds with their feet encased in concrete as we like.</a>
<a name="10">[10]</a> <a href="#10" id=10>In fact MYCIN has no way of representing processes occuring in time, although other production systems can represent processes at about the level of the situation calculus to be described in the next section.</a>
<a name="11">[11]</a> <a href="#11" id=11>The distinction is that the epistemology is completed when the facts available have as a consequence that a certain strategy is appropriate to achieve the goal, while the heuristic problem involves the search that finds the appropriate strategy.</a>
<a name="12">[12]</a> <a href="#12" id=12>In principle, Prolog goes slightly beyond this, because the expressions found as values of variables by Prolog programs can themselves involve free variables.</a>
<a name="13">[13]</a> <a href="#13" id=13>Once one decides to build an AI system that represents information declaratively, one still has to decide what kind of declarative language to allow.</a>
<a name="14">[14]</a> <a href="#14" id=14>This resembles the usual logical natural deduction systems, but for reasons beyond the scope of this lecture, it is probably not correct to regard contexts as equivalent to sets of assumptions -- not even infinite sets of assumptions.</a>
<a name="15">[15]</a> <a href="#15" id=15>Thus it cannot reason that heating a sealed container will sterilize it given that a heated bacterium dies, because it cannot reason about the unenumerated set of bacteria in the container.</a>
<a name="16">[16]</a> <a href="#16" id=16>The result of a production system pattern match is a substitution of constants for variables in the pattern part of the rule.</a>
<a name="17">[17]</a> <a href="#17" id=17>One kind of generality in AI comprises methods for finding solutions that are independent of the problem domain.</a>
</body>
</html>