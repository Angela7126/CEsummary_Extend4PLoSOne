<html>
<head>
<title>f0024.txt</title>
</head>
<body bgcolor="white">
<a name="0">[0]</a> <a href="#0" id=0>The common sense information possessed by humans would be written as logical sentences and included in the database.</a>
<a name="1">[1]</a> <a href="#1" id=1>In principle, Prolog goes slightly beyond this, because the expressions found as values of variables by Prolog programs can themselves involve free variables.</a>
<a name="2">[2]</a> <a href="#2" id=2>In my opinion, GPS was unsuccessful as a general problem solver, because problems don't take this form in general and because most of the knowledge about the common sense needed for problem solving and achieving goals is not simply representable in the form of rules for transforming expressions.</a>
<a name="3">[3]</a> <a href="#3" id=3>A production system (or a logic program) can only use this fact by substituting particular bacteria for the variables.</a>
<a name="4">[4]</a> <a href="#4" id=4>Prolog represents a local optimum in this continuum, because Horn clauses are medium expressive but can be interpreted directly by a logical problem solver.</a>
<a name="5">[5]</a> <a href="#5" id=5>Here are some situation calculus axioms for moving and painting blocks.</a>
<a name="6">[6]</a> <a href="#6" id=6>Here are some situation calculus axioms for moving and painting blocks taken from (McCarthy 1986).</a>
<a name="7">[7]</a> <a href="#7" id=7>However, a Prolog program incorporating this fragment directly can sterilize a container only by killing each bacterium individually and would require that some other part of the program successively generate the names of the bacteria.</a>
<a name="8">[8]</a> <a href="#8" id=8>Once one decides to build an AI system that represents information declaratively, one still has to decide what kind of declarative language to allow.</a>
<a name="9">[9]</a> <a href="#9" id=9>This led to STRIPS (Fikes and Nilsson 1971) which reduced the use of logic to reasoning within a situation.</a>
<a name="10">[10]</a> <a href="#10" id=10>While Friedberg's problem was learning from experience, all schemes for representing knowledge by program suffer from similar difficulties when the object is to combine disparate knowledge or to make programs that modify knowledge.</a>
<a name="11">[11]</a> <a href="#11" id=11>Consequently production systems do not infer general propositions.</a>
<a name="12">[12]</a> <a href="#12" id=12>The result of a production system pattern match is a substitution of constants for variables in the pattern part of the rule.</a>
<a name="13">[13]</a> <a href="#13" id=13>It seemed then and still seems that humans communicate mainly in declarative sentences rather than in programming languages for good objective reasons that will apply whether the communicator is a human, a creature from Alpha Centauri or a computer program.</a>
<a name="14">[14]</a> <a href="#14" id=14>In fact MYCIN has no way of representing processes occuring in time, although other production systems can represent processes at about the level of the situation calculus to be described in the next section.</a>
<a name="15">[15]</a> <a href="#15" id=15>The distinction is that the epistemology is completed when the facts available have as a consequence that a certain strategy is appropriate to achieve the goal, while the heuristic problem involves the search that finds the appropriate strategy.</a>
<a name="16">[16]</a> <a href="#16" id=16>In the first place, using general purpose theorem provers made the programs run too slowly, since the theorem provers of 1969 (Green 1969) had no way of controlling the search.</a>
<a name="17">[17]</a> <a href="#17" id=17>One kind of generality in AI comprises methods for finding solutions that are independent of the problem domain.</a>
</body>
</html>